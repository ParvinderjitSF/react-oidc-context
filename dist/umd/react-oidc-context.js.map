{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/AuthContext.ts", "../../src/AuthProvider.tsx", "../../src/AuthState.ts", "../../src/reducer.ts", "../../src/utils.ts", "../../src/useAuth.ts", "../../src/useAutoSignin.ts", "../../src/withAuth.tsx", "../../src/withAuthenticationRequired.tsx"],
  "sourcesContent": ["export * from \"./AuthContext\";\nexport * from \"./AuthProvider\";\nexport type { AuthState, ErrorContext } from \"./AuthState\";\nexport * from \"./useAuth\";\nexport * from \"./useAutoSignin\";\nexport { hasAuthParams } from \"./utils\";\nexport * from \"./withAuth\";\nexport * from \"./withAuthenticationRequired\";\n", "import React from \"react\";\nimport type {\n    UserManagerSettings, UserManagerEvents, User, SessionStatus,\n    SigninPopupArgs, SigninSilentArgs, SigninRedirectArgs,\n    SignoutRedirectArgs, SignoutPopupArgs, QuerySessionStatusArgs,\n    RevokeTokensTypes, SignoutSilentArgs, SigninResourceOwnerCredentialsArgs,\n} from \"oidc-client-ts\";\n\nimport type { AuthState } from \"./AuthState\";\n\n/**\n * @public\n */\nexport interface AuthContextProps extends AuthState {\n    /**\n     * UserManager functions. See [UserManager](https://github.com/authts/oidc-client-ts) for more details.\n     */\n    readonly settings: UserManagerSettings;\n    readonly events: UserManagerEvents;\n    clearStaleState(): Promise<void>;\n    removeUser(): Promise<void>;\n    signinPopup(args?: SigninPopupArgs): Promise<User>;\n    signinSilent(args?: SigninSilentArgs): Promise<User | null>;\n    signinRedirect(args?: SigninRedirectArgs): Promise<void>;\n    signinResourceOwnerCredentials(args: SigninResourceOwnerCredentialsArgs): Promise<User>;\n    signoutRedirect(args?: SignoutRedirectArgs): Promise<void>;\n    signoutPopup(args?: SignoutPopupArgs): Promise<void>;\n    signoutSilent(args?: SignoutSilentArgs): Promise<void>;\n    querySessionStatus(args?: QuerySessionStatusArgs): Promise<SessionStatus | null>;\n    revokeTokens(types?: RevokeTokensTypes): Promise<void>;\n    startSilentRenew(): void;\n    stopSilentRenew(): void;\n}\n\n/**\n * @public\n */\nexport const AuthContext = React.createContext<AuthContextProps | undefined>(undefined);\nAuthContext.displayName = \"AuthContext\";\n", "import type {\n    ProcessResourceOwnerPasswordCredentialsArgs,\n    SignoutResponse,\n} from \"oidc-client-ts\";\nimport { User, UserManager, type UserManagerSettings } from \"oidc-client-ts\";\nimport React from \"react\";\n\nimport { AuthContext } from \"./AuthContext\";\nimport { type ErrorContext, initialAuthState } from \"./AuthState\";\nimport { reducer } from \"./reducer\";\nimport {\n    hasAuthParams,\n    normalizeError,\n    renewSilentError,\n    signinError,\n    signoutError,\n} from \"./utils\";\n\nexport interface AuthProviderBaseProps {\n    children?: React.ReactNode;\n    onSigninCallback?: (user: User | undefined) => Promise<void> | void;\n    skipSigninCallback?: boolean;\n    matchSignoutCallback?: (args: UserManagerSettings) => boolean;\n    onSignoutCallback?: (\n        resp: SignoutResponse | undefined\n    ) => Promise<void> | void;\n    onRemoveUser?: () => Promise<void> | void;\n}\n\nexport interface AuthProviderNoUserManagerProps\n    extends AuthProviderBaseProps,\n        UserManagerSettings {\n    userManager?: never;\n}\n\nexport interface AuthProviderUserManagerProps extends AuthProviderBaseProps {\n    userManager?: UserManager;\n}\n\nexport type AuthProviderProps =\n    | AuthProviderNoUserManagerProps\n    | AuthProviderUserManagerProps;\n\nconst userManagerContextKeys = [\n    \"clearStaleState\",\n    \"querySessionStatus\",\n    \"revokeTokens\",\n    \"startSilentRenew\",\n    \"stopSilentRenew\",\n] as const;\nconst navigatorKeys = [\n    \"signinPopup\",\n    \"signinSilent\",\n    \"signinRedirect\",\n    \"signinResourceOwnerCredentials\",\n    \"signoutPopup\",\n    \"signoutRedirect\",\n    \"signoutSilent\",\n] as const;\nconst unsupportedEnvironment = (fnName: string) => () => {\n    throw new Error(\n        `UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`\n    );\n};\n\nconst UserManagerImpl = typeof window === \"undefined\" ? null : UserManager;\n\nexport const AuthProvider = (props: AuthProviderProps): React.JSX.Element => {\n    const {\n        children,\n        onSigninCallback,\n        skipSigninCallback,\n        matchSignoutCallback,\n        onSignoutCallback,\n        onRemoveUser,\n        userManager: userManagerProp = null,\n        ...userManagerSettings\n    } = props;\n\n    const userManagerRef = React.useRef<UserManager | null>(null);\n    const createdInternally = React.useRef<boolean>(false);\n\n    if (!userManagerRef.current) {\n        if (userManagerProp) {\n            userManagerRef.current = userManagerProp;\n            createdInternally.current = false;\n        } else {\n            userManagerRef.current = UserManagerImpl\n                ? new UserManagerImpl(\n                      userManagerSettings as UserManagerSettings\n                  )\n                : ({ settings: userManagerSettings } as UserManager);\n            createdInternally.current = true;\n        }\n    }\n\n    const userManager = userManagerRef.current!;\n    const [state, dispatch] = React.useReducer(reducer, initialAuthState);\n\n    const userManagerContext = React.useMemo(\n        () =>\n            Object.assign(\n                {\n                    settings: userManager.settings,\n                    events: userManager.events,\n                },\n                Object.fromEntries(\n                    userManagerContextKeys.map((key) => [\n                        key,\n                        userManager[key]?.bind(userManager) ??\n                            unsupportedEnvironment(key),\n                    ])\n                ) as Pick<UserManager, (typeof userManagerContextKeys)[number]>,\n                Object.fromEntries(\n                    navigatorKeys.map((key) => [\n                        key,\n                        userManager[key]\n                            ? async (\n                                  args: ProcessResourceOwnerPasswordCredentialsArgs &\n                                      never[]\n                              ) => {\n                                  dispatch({\n                                      type: \"NAVIGATOR_INIT\",\n                                      method: key,\n                                  });\n                                  try {\n                                      return await userManager[key](args);\n                                  } catch (error) {\n                                      dispatch({\n                                          type: \"ERROR\",\n                                          error: {\n                                              ...normalizeError(\n                                                  error,\n                                                  `Unknown error while executing ${key}(...).`\n                                              ),\n                                              source: key,\n                                              args,\n                                          } as ErrorContext,\n                                      });\n                                      return null;\n                                  } finally {\n                                      dispatch({ type: \"NAVIGATOR_CLOSE\" });\n                                  }\n                              }\n                            : unsupportedEnvironment(key),\n                    ])\n                ) as Pick<UserManager, (typeof navigatorKeys)[number]>\n            ),\n        [userManager]\n    );\n\n    const didInitialize = React.useRef(false);\n\n    React.useEffect(() => {\n        if (!userManager || didInitialize.current) return;\n        didInitialize.current = true;\n\n        void (async () => {\n            try {\n                let user: User | undefined | null = null;\n\n                if (hasAuthParams() && !skipSigninCallback) {\n                    user = await userManager.signinCallback();\n                    if (onSigninCallback) await onSigninCallback(user);\n                }\n\n                user = user ?? (await userManager.getUser());\n                dispatch({ type: \"INITIALISED\", user });\n            } catch (error) {\n                dispatch({ type: \"ERROR\", error: signinError(error) });\n            }\n\n            try {\n                if (matchSignoutCallback?.(userManager.settings)) {\n                    const resp = await userManager.signoutCallback();\n                    if (onSignoutCallback) await onSignoutCallback(resp);\n                }\n            } catch (error) {\n                dispatch({ type: \"ERROR\", error: signoutError(error) });\n            }\n        })();\n    }, [\n        userManager,\n        skipSigninCallback,\n        onSigninCallback,\n        onSignoutCallback,\n        matchSignoutCallback,\n    ]);\n\n    React.useEffect(() => {\n        const handleUserLoaded = (user: User) =>\n            dispatch({ type: \"USER_LOADED\", user });\n        const handleUserUnloaded = () => dispatch({ type: \"USER_UNLOADED\" });\n        const handleUserSignedOut = () => dispatch({ type: \"USER_SIGNED_OUT\" });\n        const handleSilentRenewError = (error: Error) =>\n            dispatch({ type: \"ERROR\", error: renewSilentError(error) });\n\n        userManager.events.addUserLoaded(handleUserLoaded);\n        userManager.events.addUserUnloaded(handleUserUnloaded);\n        userManager.events.addUserSignedOut(handleUserSignedOut);\n        userManager.events.addSilentRenewError(handleSilentRenewError);\n\n        return () => {\n            userManager.events.removeUserLoaded(handleUserLoaded);\n            userManager.events.removeUserUnloaded(handleUserUnloaded);\n            userManager.events.removeUserSignedOut(handleUserSignedOut);\n            userManager.events.removeSilentRenewError(handleSilentRenewError);\n\n            if (createdInternally.current) {\n                userManager.stopSilentRenew?.();\n                userManager.clearStaleState?.();\n            }\n        };\n    }, [userManager]);\n\n    const removeUser = React.useCallback(async () => {\n        if (!userManager) unsupportedEnvironment(\"removeUser\");\n        await userManager.removeUser();\n        if (onRemoveUser) await onRemoveUser();\n    }, [userManager, onRemoveUser]);\n\n    const contextValue = React.useMemo(() => {\n        return {\n            ...state,\n            ...userManagerContext,\n            removeUser,\n        };\n    }, [state, userManagerContext, removeUser]);\n\n    return (\n        <AuthContext.Provider value={contextValue}>\n            {children}\n        </AuthContext.Provider>\n    );\n};\n", "import type {\n    SigninPopupArgs,\n    SigninRedirectArgs,\n    SigninResourceOwnerCredentialsArgs,\n    SigninSilentArgs,\n    SignoutPopupArgs,\n    SignoutRedirectArgs,\n    SignoutSilentArgs,\n    User,\n} from \"oidc-client-ts\";\n\n/**\n * The auth state which, when combined with the auth methods, make up the return object of the `useAuth` hook.\n *\n * @public\n */\nexport interface AuthState {\n    /**\n     * See [User](https://authts.github.io/oidc-client-ts/classes/User.html) for more details.\n     */\n    user?: User | null;\n\n    /**\n     * True when the library has been initialized and no navigator request is in progress.\n     */\n    isLoading: boolean;\n\n    /**\n     * True while the user has a valid access token.\n     */\n    isAuthenticated: boolean;\n\n    /**\n     * Tracks the status of most recent signin/signout request method.\n     */\n    activeNavigator?: \"signinRedirect\" | \"signinResourceOwnerCredentials\" | \"signinPopup\" | \"signinSilent\" | \"signoutRedirect\" | \"signoutPopup\" | \"signoutSilent\";\n\n    /**\n     * Was there a signin or silent renew error?\n     */\n    error?: ErrorContext;\n}\n\n/**\n * Represents an error while execution of a signing, renew, ...\n *\n * @public\n */\nexport type ErrorContext = Error & {\n    innerError?: unknown;\n} & ({ source: \"signinCallback\" }\n    | { source: \"signoutCallback\" }\n    | { source: \"renewSilent\" }\n\n    | { source: \"signinPopup\"; args: SigninPopupArgs | undefined }\n    | { source: \"signinSilent\"; args: SigninSilentArgs | undefined }\n    | { source: \"signinRedirect\"; args: SigninRedirectArgs | undefined }\n    | { source: \"signinResourceOwnerCredentials\"; args: SigninResourceOwnerCredentialsArgs | undefined }\n    | { source: \"signoutPopup\"; args: SignoutPopupArgs | undefined }\n    | { source: \"signoutRedirect\"; args: SignoutRedirectArgs | undefined }\n    | { source: \"signoutSilent\"; args: SignoutSilentArgs | undefined }\n\n    | { source: \"unknown\" }\n);\n\n/**\n * The initial auth state.\n */\nexport const initialAuthState: AuthState = {\n    isLoading: true,\n    isAuthenticated: false,\n};\n", "import type { User } from \"oidc-client-ts\";\n\nimport type { AuthState, ErrorContext } from \"./AuthState\";\n\ntype Action =\n    | { type: \"INITIALISED\" | \"USER_LOADED\"; user: User | null }\n    | { type: \"USER_UNLOADED\" }\n    | { type: \"USER_SIGNED_OUT\" }\n    | { type: \"NAVIGATOR_INIT\"; method: NonNullable<AuthState[\"activeNavigator\"]> }\n    | { type: \"NAVIGATOR_CLOSE\" }\n    | { type: \"ERROR\"; error: ErrorContext };\n\n/**\n * Handles how that state changes in the `useAuth` hook.\n */\nexport const reducer = (state: AuthState, action: Action): AuthState => {\n    switch (action.type) {\n        case \"INITIALISED\":\n        case \"USER_LOADED\":\n            return {\n                ...state,\n                user: action.user,\n                isLoading: false,\n                isAuthenticated: action.user ? !action.user.expired : false,\n                error: undefined,\n            };\n        case \"USER_SIGNED_OUT\":\n        case \"USER_UNLOADED\":\n            return {\n                ...state,\n                user: undefined,\n                isAuthenticated: false,\n            };\n        case \"NAVIGATOR_INIT\":\n            return {\n                ...state,\n                isLoading: true,\n                activeNavigator: action.method,\n            };\n        case \"NAVIGATOR_CLOSE\":\n            // we intentionally don't handle cases where multiple concurrent navigators are open\n            return {\n                ...state,\n                isLoading: false,\n                activeNavigator: undefined,\n            };\n        case \"ERROR\": {\n            const error = action.error;\n            error[\"toString\"] = () => `${error.name}: ${error.message}`;\n            return {\n                ...state,\n                isLoading: false,\n                error,\n            };\n        }\n        default: {\n            const innerError = new TypeError(`unknown type ${action[\"type\"] as string}`);\n            const error = {\n                name: innerError.name,\n                message: innerError.message,\n                innerError,\n                stack: innerError.stack,\n                source: \"unknown\",\n            } satisfies ErrorContext;\n            error[\"toString\"] = () => `${error.name}: ${error.message}`;\n            return {\n                ...state,\n                isLoading: false,\n                error,\n            };\n        }\n    }\n};\n", "import type { ErrorContext } from \"./AuthState\";\n\n/**\n * @public\n */\nexport const hasAuthParams = (location = window.location): boolean => {\n    // response_mode: query\n    let searchParams = new URLSearchParams(location.search);\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\n        searchParams.get(\"state\")) {\n        return true;\n    }\n\n    // response_mode: fragment\n    searchParams = new URLSearchParams(location.hash.replace(\"#\", \"?\"));\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\n        searchParams.get(\"state\")) {\n        return true;\n    }\n\n    return false;\n};\n\nexport const signinError = normalizeErrorFn(\"signinCallback\", \"Sign-in failed\");\nexport const signoutError = normalizeErrorFn(\"signoutCallback\", \"Sign-out failed\");\nexport const renewSilentError = normalizeErrorFn(\"renewSilent\", \"Renew silent failed\");\n\nexport function normalizeError(error: unknown, fallbackMessage: string): Pick<ErrorContext, \"name\" | \"message\" | \"innerError\" | \"stack\"> {\n    return {\n        name: stringFieldOf(error, \"name\", () => \"Error\"),\n        message: stringFieldOf(error, \"message\", () => fallbackMessage),\n        stack: stringFieldOf(error, \"stack\", () => new Error().stack),\n        innerError: error,\n    };\n}\n\nfunction normalizeErrorFn(source: \"signoutCallback\" | \"signinCallback\" | \"renewSilent\", fallbackMessage: string) {\n    return (error: unknown): ErrorContext => {\n        return {\n            ...normalizeError(error, fallbackMessage),\n            source: source,\n        };\n    };\n}\n\nfunction stringFieldOf(element: unknown, fieldName: string, or: () => string): string;\nfunction stringFieldOf(element: unknown, fieldName: string, or: () => string | undefined): string | undefined;\nfunction stringFieldOf(element: unknown, fieldName: string, or: () => string | undefined): string | undefined {\n    if (element && typeof element === \"object\") {\n        const value = (element as Record<string, unknown>)[fieldName];\n        if (typeof value === \"string\") {\n            return value;\n        }\n    }\n    return or();\n}\n", "import React from \"react\";\n\nimport { AuthContext, type AuthContextProps } from \"./AuthContext\";\n\n/**\n * @public\n */\nexport const useAuth = (): AuthContextProps => {\n    const context = React.useContext(AuthContext);\n\n    if (!context) {\n        console.warn(\"AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.\");\n    }\n\n    return context as AuthContextProps;\n};\n", "import React from \"react\";\nimport { useAuth } from \"./useAuth\";\nimport { hasAuthParams } from \"./utils\";\nimport type { AuthContextProps } from \"./AuthContext\";\nimport type { AuthState } from \"./AuthState\";\n\ntype UseAutoSignInProps = {\n    signinMethod?: keyof Pick<AuthContextProps, \"signinRedirect\" | \"signinPopup\">;\n}\n\ntype UseAutoSignInReturn = Pick<AuthState, \"isAuthenticated\" | \"isLoading\" | \"error\">\n\n/**\n * @public\n *\n * Automatically attempts to sign in a user based on the provided sign-in method and authentication state.\n *\n * This hook manages automatic sign-in behavior for a user. It uses the specified sign-in\n * method, the current authentication state, and ensures the sign-in attempt is made only once\n * in the application context.\n *\n * Does not support the `signinResourceOwnerCredentials` method!\n *\n * @param options - (Optional) Configuration object for the sign-in method. Default to `{ signinMethod: \"signinRedirect\" }`.\n *       Possible values for `signinMethod` are:\n *        - `\"signinRedirect\"`: Redirects the user to the sign-in page (default).\n *        - `\"signinPopup\"`: Signs in the user through a popup.\n *\n * @returns The current status of the authentication process.\n */\nexport const useAutoSignin = ({ signinMethod = \"signinRedirect\" }: UseAutoSignInProps = {}): UseAutoSignInReturn => {\n    const auth = useAuth();\n    const [hasTriedSignin, setHasTriedSignin] = React.useState(false);\n\n    const shouldAttemptSignin = React.useMemo(() => !hasAuthParams() && !auth.isAuthenticated && !auth.activeNavigator && !auth.isLoading &&\n        !hasTriedSignin, [auth.activeNavigator, auth.isAuthenticated, auth.isLoading, hasTriedSignin]);\n\n    React.useEffect(() => {\n        if (shouldAttemptSignin) {\n            switch (signinMethod) {\n                case \"signinPopup\":\n                    void auth.signinPopup();\n                    break;\n                case \"signinRedirect\":\n                default:\n                    void auth.signinRedirect();\n                    break;\n            }\n\n            setHasTriedSignin(true);\n        }\n    }, [auth, hasTriedSignin, shouldAttemptSignin, signinMethod]);\n\n    return {\n        isLoading: auth.isLoading,\n        isAuthenticated: auth.isAuthenticated,\n        error: auth.error,\n    };\n};\n", "import React from \"react\";\n\nimport type { AuthContextProps } from \"./AuthContext\";\nimport { useAuth } from \"./useAuth\";\n\n/**\n * A public higher-order component to access the imperative API\n * @public\n */\nexport function withAuth<P>(\n    Component: React.ComponentType<P>,\n): React.ComponentType<Omit<P, keyof AuthContextProps>> {\n    const displayName = `withAuth(${Component.displayName || Component.name})`;\n    const C: React.FC<Omit<P, keyof AuthContextProps>> = (props) => {\n        const auth = useAuth();\n\n        return <Component {...(props as P)} auth={auth} />;\n    };\n\n    C.displayName = displayName;\n\n    return C;\n}\n", "import React from \"react\";\nimport type { SigninRedirectArgs } from \"oidc-client-ts\";\n\nimport { useAuth } from \"./useAuth\";\nimport { hasAuthParams } from \"./utils\";\n\n/**\n * @public\n */\nexport interface WithAuthenticationRequiredProps {\n    /**\n     * Show a message when redirected to the signin page.\n     */\n    OnRedirecting?: () => React.JSX.Element;\n\n    /**\n     * Allows executing logic before the user is redirected to the signin page.\n     */\n    onBeforeSignin?: () => Promise<void> | void;\n\n    /**\n     * Pass additional signin redirect arguments.\n     */\n    signinRedirectArgs?: SigninRedirectArgs;\n}\n\n/**\n * A public higher-order component to protect accessing not public content. When you wrap your components in this higher-order\n * component and an anonymous user visits your component, they will be redirected to the login page; after logging in, they\n * will return to the page from which they were redirected.\n *\n * @public\n */\nexport const withAuthenticationRequired = <P extends object>(\n    Component: React.ComponentType<P>,\n    options: WithAuthenticationRequiredProps = {},\n): React.FC<P> => {\n    const { OnRedirecting = (): React.JSX.Element => <></>, onBeforeSignin, signinRedirectArgs } = options;\n    const displayName = `withAuthenticationRequired(${Component.displayName || Component.name})`;\n    const C: React.FC<P> = (props) => {\n        const auth = useAuth();\n\n        React.useEffect(() => {\n            if (hasAuthParams() ||\n                auth.isLoading || auth.activeNavigator || auth.isAuthenticated) {\n                return;\n            }\n            void (async (): Promise<void> => {\n                if (onBeforeSignin) await onBeforeSignin();\n                await auth.signinRedirect(signinRedirectArgs);\n            })();\n        }, [auth.isLoading, auth.isAuthenticated, auth]);\n\n        return auth.isAuthenticated ? <Component {...props} /> : OnRedirecting();\n    };\n\n    C.displayName = displayName;\n\n    return C;\n};\n"],
  "mappings": "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",
  "names": ["React", "import_react", "React", "import_react", "React", "import_react", "React", "import_react", "React", "import_react", "React"]
}
